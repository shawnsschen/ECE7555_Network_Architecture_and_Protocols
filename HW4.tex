%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[titlepage, paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{listings}

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{graphicx}


\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{University of Virginia} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge ECE/CS 5565 Homework 4 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Shawn (Shuoshuo) Chen\\sc7cq@virginia.edu} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	PROBLEM 27
%----------------------------------------------------------------------------------------

\section*{Problem 27}
\textbf{(a).}
Sequence number is $127+80=207$, source port is 302, destination port is 80. \\

\textbf{(b).}
The ACK number should be the next expected byte, which is the cumulative bytes plus one.
So the ACK number is 207, source port is 80 and destination port is 302. \\

\textbf{(c).}
The receiver is expecting the segment with seqnum=127, but it gets a segment with seqnum=207.
Then the receiver knows there is a missing segment. Accroding to the behavior of TCP. the receiver
would still ACK 127. \\

\textbf{(d).}
See figure \ref{fig:p27}.
\begin{figure}[!ht]
    \includegraphics[width=\textwidth]{images/p27.pdf}
    \caption{Coomunication sequence between A and B}
    \label{fig:p27}
\end{figure}
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 31
%----------------------------------------------------------------------------------------

\section*{Problem 31}
After the first measurement:
\begin{align*} 
\begin{split}
EstimatedRTT &= (1-\alpha)*EstimatedRTT + \alpha * SampleRTT \\
&= (1-0.125)*100 + 0.125 * 106 \\
&= 100.75 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
DevRTT &= (1-\beta)*DevRTT + \beta * | SampleRTT - EstimatedRTT | \\
&= (1-0.25)*5 + 0.25 * | 106 - 100.75 | \\
&= 5.0625 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
TimeoutInterval &= EstimatedRTT + 4*DevRTT \\
&= 100.75 + 4*5.0625 \\
&= 121 \quad ms
\end{split}					
\end{align*}
After the second measurement:
\begin{align*} 
\begin{split}
EstimatedRTT &= (1-\alpha)*EstimatedRTT + \alpha * SampleRTT \\
&= (1-0.125)*100.75 + 0.125 * 120 \\
&= 103.16 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
DevRTT &= (1-\beta)*DevRTT + \beta * | SampleRTT - EstimatedRTT | \\
&= (1-0.25)*5.0625 + 0.25 * | 120 - 103.16 | \\
&= 8 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
TimeoutInterval &= EstimatedRTT + 4*DevRTT \\
&= 103.16 + 4*8 \\
&= 135.16 \quad ms
\end{split}					
\end{align*}
After the third measurement:
\begin{align*} 
\begin{split}
EstimatedRTT &= (1-\alpha)*EstimatedRTT + \alpha * SampleRTT \\
&= (1-0.125)*103.16 + 0.125 * 140 \\
&= 107.765 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
DevRTT &= (1-\beta)*DevRTT + \beta * | SampleRTT - EstimatedRTT | \\
&= (1-0.25)*8 + 0.25 * | 140 - 107.765 | \\
&= 14.06 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
TimeoutInterval &= EstimatedRTT + 4*DevRTT \\
&= 107.765 + 4*14.06 \\
&= 164.005 \quad ms
\end{split}					
\end{align*}
After the fourth measurement:
\begin{align*} 
\begin{split}
EstimatedRTT &= (1-\alpha)*EstimatedRTT + \alpha * SampleRTT \\
&= (1-0.125)*107.765 + 0.125 * 90 \\
&= 105.54 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
DevRTT &= (1-\beta)*DevRTT + \beta * | SampleRTT - EstimatedRTT | \\
&= (1-0.25)*14.06 + 0.25 * | 90 - 105.54 | \\
&= 14.43 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
TimeoutInterval &= EstimatedRTT + 4*DevRTT \\
&= 105.54 + 4*14.43 \\
&= 163.26 \quad ms
\end{split}					
\end{align*}
After the fifth measurement:
\begin{align*} 
\begin{split}
EstimatedRTT &= (1-\alpha)*EstimatedRTT + \alpha * SampleRTT \\
&= (1-0.125)*105.54 + 0.125 * 115 \\
&= 106.72 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
DevRTT &= (1-\beta)*DevRTT + \beta * | SampleRTT - EstimatedRTT | \\
&= (1-0.25)*14.43 + 0.25 * | 115 - 106.72 | \\
&= 12.8925 \quad ms
\end{split}					
\end{align*}
\begin{align*} 
\begin{split}
TimeoutInterval &= EstimatedRTT + 4*DevRTT \\
&= 106.72 + 4*12.8925 \\
&= 158.29 \quad ms
\end{split}					
\end{align*}
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 38
%----------------------------------------------------------------------------------------
\section*{Problem 38}
Yes. In the slow start phase, the sending rate is growing exponentially. When congestion occurs,
the sender is sending segments twice more than in previous RTT. This implies, by doubling the sending
rate, sender hits the link limit. So setting ssthresh = cwnd/2 is a proper choice because it gives us
the approximate uncongested sending rate. And the sending rate when congestion occurs should be
roughly cwnd/RTT.



%----------------------------------------------------------------------------------------
%	PROBLEM 40
%----------------------------------------------------------------------------------------

\section*{Problem 40}
(a).
TCP slow start is operating in [1, 6] and [23, 26]. These two segments of curve looks exponential. \\
(b).
Congestion avoidance is operating in [6, 16] and [17, 22]. These two segments show linearity. \\
(c).
It is detected by a triple duplicate ACK. Because the cwnd would have dropped to 1 if timeout occurs. \\
(d).
It is detected by a timeout because cwnd has dropped to 1. \\
(e).
Initial value is 32 because it enters congestion avoidance after $cwnd \geq 32$. \\
(f).
ssthresh is 21 since it should be set to half of cwnd when a triple duplicate ACK occurs. \\
(g).
ssthresh is 14 because when timeout occurs, it will be set to half of the cwnd, which is 28 at round 22. \\
(h).
In the slow start phase, segments sent in each round are 1, 2, 4, 8, 16, 32. So by the end of round 6, 63 segments are sent. And then it goes into congestion avoidance, where $cwnd=32$. So another 32 segments are sent in round 7. That is 95 segments in total. So segmetn 70 is sent in round 7. \\
(i).
After round 26, TCP enters fast recovery mode. It sets the ssthresh to cwnd/2, which is 4. And the new cwnd=ssthresh+3=7. \\
(j).
At round 16, ssthresh is set to cwnd/2=21. And cwnd is set to 1. Then TCP goes to slow start again. Thus, at round 19, the cwnd=4. \\
(k).
A timeout at round 22 would not affect previous rounds. So the total segments sent should be 24+25+26+27+28+29=159. \\


%----------------------------------------------------------------------------------------
%	PROBLEM 12
%----------------------------------------------------------------------------------------

\section*{Problem 12}
The protocol will still work, but it would probably cause a huge amount of retransmission. \\
Imagine the timer is premature, thus it goes off before the first ACK comes back. An extra copy of
the packet is sent. Then if bit error occurs causing the ACK to be corrupted, another extra copy of the packet will be sent again. So in the worst case, a packet could be sent 3 times plus as many times as the number of ACKs for previous packets on the way.
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 13
%----------------------------------------------------------------------------------------

\section*{Problem 13}
As figure \ref{fig:p13} shows, the first D0 is reordered and appears right before the new D0.
This would confuse the receiver since receiver might take the reordered D0, which it has already received,
as the new D0 expected.
\begin{figure}[!ht]
    \includegraphics[width=\textwidth]{images/P13.pdf}
    \caption{Out-of-sequence problem}
    \label{fig:p13}
\end{figure}
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 15
%----------------------------------------------------------------------------------------

\section*{Problem 15}
This is a pipelining scenario. According to the definition of utilization, there is:
\begin{align*} 
\begin{split}
U_{sender} = \frac{n*L/R}{RTT+L/R} \geq 0.98
\end{split}					
\end{align*}
where L = 1500 bytes, R = 1 Gbps, RTT = 0.03 sec and n is the window size.
Thus:
\begin{align*} 
\begin{split}
U_{sender} &= \frac{n*L/R}{RTT+L/R} \\
&=  \frac{n*1500*8/1000000000}{0.03+1500*8/1000000000} \geq 0.98
\end{split}					
\end{align*}
Solve for n, there is $n=2451$ packets.
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 18
%----------------------------------------------------------------------------------------

\section*{Problem 18}
The FSM of this protocol is described by figure \ref{fig:p18-s} and figure \ref{fig:p18-r}.
\begin{figure}[!ht]
    \includegraphics[width=\textwidth]{images/P18-sender.pdf}
    \caption{Sender FSM}
    \label{fig:p18-s}
\end{figure}
\begin{figure}[!ht]
    \includegraphics[width=\textwidth]{images/P18-receiver.pdf}
    \caption{Receiver FSM}
    \label{fig:p18-r}
\end{figure}
As an example of explaining how this protocol works, suppose sender sends (D0, D1).
D0 gets lost and D1 is successfully delivered. Once the receiver receives D1, it ACKs D1 with ACK1.
After sender receives ACK1, it stays in the state that waits for ACK0. But since D0 is lost, there will be no ACK0 until timeout occurs. Then sender resends D0. Receiver receives D0 this time and sends back ACK0. Sender gets ACK0 and goes back to the initial state to send a new pair (D2, D3).



%----------------------------------------------------------------------------------------
%	PROBLEM 22
%----------------------------------------------------------------------------------------

\section*{Problem 22}
\textbf{(a). }
Assume all the previous k-1 ACKs are successfully received by the sender, the sender base is now at
k. So the window looks like [k, k+3]. \\
Also, there is another possibility that ACK for k-1 is lost. So the sender base is at k-1, and the window looks like [k-1, k+2]. Similarly, there could be multiple ACKs lost up to k-1. Thus the sender window can also be [k-2, k+1], [k-3, k] and [k-4, k-1]. \\

\textbf{(b).}
Since the receiver is expecting k, it means it has already received k-1. And the window size is 4, so the oldest unacknowledged packet can be k-4. Thus, the propagating ACKs could have value k-4, k-3, k-2, k-1.
\\


%----------------------------------------------------------------------------------------
%	PROBLEM 23
%----------------------------------------------------------------------------------------

\section*{Problem 23}
By looking at Figure 3.27, we see that the receiver cannot tell whether packet 0 is a new one or a retransmitted one because the sender has the old packet 0 is its window and the receiver has the new packet 0 in its window. They are overlapped to be confusing. \\
To solve this problem, assume the receiver has window [k, k+w-1] where w is the window size. In the worst case discussed in problem 22, the propagating ACK could be k-w to k-1. If $k-w = k+w-1$ in the modulo k arithmetic, and unfortunately it is missing, then the receiver will be confused by the retransmitted packet k-w. Thus, k-w cannot overlap k+w-1. In other words, the window size should be at most half of the sequence number space.
\\



\end{document}
